compiler made by following steps on this page https://www.sigbus.info/compilerbook

# How does this works?

the given source code is compiled following these steps.

1. tokenize - convert string to array of tokens which is like a word in English e.g. ("if", "a", "123", ";", "("...)
2. parse - conver array of tokens to tree structure of program.
3. code generation - generate code from tree structure of the program generated by "parse" step.


## Tokenize

In this program, array of tokens are declared as a pointer to a structure (which has pointer to the next array of tokens.)

The global variable ```Token* token;``` in tokenize.c is the array of tokens.

### What is consume() and expect() fuinctions?

to avoid complications from accessing global variable of token from parsing-functions, ```consume...()``` function and ```expect...()``` functions are declared.
These functions reads current token and checks whether it matches certain conditions specified by function parameters and each different functions like ```consume()```, ```expectNum()``` etc.

The difference of ```consume...()``` and ```expect...()``` is the action when the token doesn't matches the conditions.
```consume``` simply returns bool of whether the token matches the conditions.
```expect``` functions outputs error and exits the program when the next token doesn't matches the conditions.

```atEof()``` function is also this type of function. This function's condition is whether it's EOF token or not. And this is ```consume```-type function

## Parse


In order to convert array of token to tree structure of the program, I used recursive descent parsing.

**The tree structure has many point to improve. So I'm welcome for any improvement especially for this section of code.**

```
program = function*
function = ident '(' ')' block
arglist = (ident ',')* ident?
block = '{' statements
statements = statement (statements | '}')?
statement = expression ';'
          | 'return' expression ';'
          | 'if' '(' expression ')' block ('else' block)?
          | 'while' '(' expression ')' block
expression = assign
assign = equality ('=' assign)?
equality = comp ( '==' comp | '!-' comp)*
comp = add ( '>' add | '>=' add | '<' add | '<=' add)*
add = mul ( '+' mul | '-' mul)*
mul = unary ( '*' unary | '/' unary )*
unary = ('+' | '-')? dereference
dereference = '*'* primary
primary = num
        | ident ('(' (expression (',' expression)*)? ')')?
        | '(' assign ')'
        | address
address = '&' ident
```

Here is an example.

```
myadd (a, b)
{
    return a + b;
}

main ()
{
    i = 0;
    while (i < 10)
    {
        i = myadd(i, 1);
    }
    return i;
}
```

This program is converted to tree structure like this.

```
 type : PROGRAM
    type : FUNCTION_DEF
    function name : myadd
    function name len : 5
        type : FUNCTION_ARGUMENT
            type : LVAL
            value id : 1
            type : LVAL
            value id : 2
        type : RETURN
            type : ADD
                type : LVAL
                value id : 1
                type : LVAL
                value id : 2
    type : FUNCTION_DEF
    function name : main
    function name len : 4
        type : STATEMENT
            type : ASSIGN
                type : LVAL
                value id : 1
                type : NUM
                value : 0
            type : STATEMENT
                type : WHILE
                    type : LESS
                        type : LVAL
                        value id : 1
                        type : NUM
                        value : 10
                    type : ASSIGN
                        type : LVAL
                        value id : 1
                        type : FUNCTION_CALL
                        name : myadd
                        param count : 2
                            type : FUNCTION_CALL_PARAM
                                type : LVAL
                                value id : 1
                                type : FUNCTION_CALL_PARAM
                                    type : NUM
                                    value : 1
                type : RETURN
                    type : LVAL
                    value id : 1
```



### Tree program structure

Each node of the tree has These following members;

* NodeType which 
* Lhs and Rhs which stands for Left/Right hand side node.
* Additional information for specific node. e.g. (Function name for NT_FUNCTRION, value for NT_NUM)

### Tree Node types

#### NT_PROGRAM

#### NT_FUNCTION_DEF


## Codegen

Outputs assembly from tree structure of the program.

The assembly follows System V ABI. (I just followed the steps on the site. Therefore, there may be codes that are outputting wrong asm)





